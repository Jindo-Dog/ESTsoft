<!DOCTYPE html>
<html lang = "en">
<head>
	<meta charset = "UTF-8">
	<title>Map과 Set</title>
</head>
<body>
	<script>
		/** Set
		 * 중복을
		 * 중복하지 않은 데이터를 저장할 때 사용
		 * 중복을 제거하는 용도로도 사용
		 */

				// let s = new Set();
				// console.log(s); // Set(0) {}

		let s = new Set();

		s.add(10);
		s.add(20);
		s.add(30);
		s.add(30);	// 중복된 값은 추가되지 않는다
		s.add(30);
		console.log(s);

		let ss = new Set('abcdeeeeeeeeeeee');
		console.log(ss);		// Set(5) {"a", "b", "c", "d", "e"}
		console.log(ss.size);	// 5

		let sss = new Set([10, 20, 30, 10, 20, 30, 30]);
		console.log(sss);				// Set(3) {10, 20, 30}
		console.log(sss.size);			// 3
		console.log(sss.has(10));		// true
		console.log(sss.delete(10));	// true
		console.log(sss.has(10));		// false

		let s2 = new Set(['apple', 'banana', 'orange']);
		for (let value of s2) {
			console.log(value);
		}


		let setA = new Set(['apple', 'banana', 'orange']);
		let setB = new Set(['banana', 'kiwi', 'orange']);

		// 교집합
		let intersection = new Set([...setA].filter(x => setB.has(x)));
		console.log(intersection); // Set(2) {"banana", "orange"}

		// 합집합
		let union = new Set([...setA, ...setB]);
		console.log(union); // Set(4) {"apple", "banana", "orange", "kiwi"}

		// 차집합
		let difference = new Set([...setA].filter(x => !setB.has(x)));
		console.log(difference); // Set(1) {"apple"}


		// array에 filter와 reduce
		// filter는 안에 들어간 함수가 true를 리턴하는 요소만 모아서 새로운 배열을 만든다
		let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
		let result = arr.filter(x => x % 2 === 0);	// 짝수만 추출
		let result = arr.filter(x => x > 5);		// 5보다 큰 수만 추출

		// reduce는 각 배열의 각 요소를 연산한다
		let arr2 = [1, 2, 3, 4, 5];
		let result2 = arr2.reduce((acc, cur) => acc + cur, 0);	// acc는 누적값(accumulator), cur은 현재값(current value), 0은 초기값
		// 0이 없으면 비어있는 배열일 때 에러가 난다
	</script>
</body>
</html>